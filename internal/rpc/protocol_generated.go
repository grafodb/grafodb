// automatically generated by the FlatBuffers compiler, do not modify

package rpc

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

const (
	CmdPing              = 0
	CmdClusterMemberList = 1
	CmdClusterStatus     = 2
)

var EnumNamesCmd = map[int]string{
	CmdPing:              "Ping",
	CmdClusterMemberList: "ClusterMemberList",
	CmdClusterStatus:     "ClusterStatus",
}

type Request struct {
	_tab flatbuffers.Table
}

func GetRootAsRequest(buf []byte, offset flatbuffers.UOffsetT) *Request {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Request{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Request) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Request) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Request) Command() uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Request) MutateCommand(n uint16) bool {
	return rcv._tab.MutateUint16Slot(4, n)
}

func (rcv *Request) Version() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Request) MutateVersion(n byte) bool {
	return rcv._tab.MutateByteSlot(6, n)
}

func (rcv *Request) Payload(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *Request) PayloadLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Request) PayloadBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func RequestStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func RequestAddCommand(builder *flatbuffers.Builder, command uint16) {
	builder.PrependUint16Slot(0, command, 0)
}
func RequestAddVersion(builder *flatbuffers.Builder, version byte) {
	builder.PrependByteSlot(1, version, 0)
}
func RequestAddPayload(builder *flatbuffers.Builder, payload flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(payload), 0)
}
func RequestStartPayloadVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func RequestEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type Response struct {
	_tab flatbuffers.Table
}

func GetRootAsResponse(buf []byte, offset flatbuffers.UOffsetT) *Response {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Response{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Response) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Response) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Response) IsError() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Response) MutateIsError(n byte) bool {
	return rcv._tab.MutateByteSlot(4, n)
}

func (rcv *Response) Command() uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Response) MutateCommand(n uint16) bool {
	return rcv._tab.MutateUint16Slot(6, n)
}

func (rcv *Response) Version() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Response) MutateVersion(n byte) bool {
	return rcv._tab.MutateByteSlot(8, n)
}

func (rcv *Response) Payload(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *Response) PayloadLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Response) PayloadBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func ResponseStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func ResponseAddIsError(builder *flatbuffers.Builder, isError byte) {
	builder.PrependByteSlot(0, isError, 0)
}
func ResponseAddCommand(builder *flatbuffers.Builder, command uint16) {
	builder.PrependUint16Slot(1, command, 0)
}
func ResponseAddVersion(builder *flatbuffers.Builder, version byte) {
	builder.PrependByteSlot(2, version, 0)
}
func ResponseAddPayload(builder *flatbuffers.Builder, payload flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(payload), 0)
}
func ResponseStartPayloadVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func ResponseEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ErrorResponse struct {
	_tab flatbuffers.Table
}

func GetRootAsErrorResponse(buf []byte, offset flatbuffers.UOffsetT) *ErrorResponse {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ErrorResponse{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *ErrorResponse) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ErrorResponse) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ErrorResponse) Code() uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ErrorResponse) MutateCode(n uint16) bool {
	return rcv._tab.MutateUint16Slot(4, n)
}

func (rcv *ErrorResponse) Message() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func ErrorResponseStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func ErrorResponseAddCode(builder *flatbuffers.Builder, code uint16) {
	builder.PrependUint16Slot(0, code, 0)
}
func ErrorResponseAddMessage(builder *flatbuffers.Builder, message flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(message), 0)
}
func ErrorResponseEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type Member struct {
	_tab flatbuffers.Table
}

func GetRootAsMember(buf []byte, offset flatbuffers.UOffsetT) *Member {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Member{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Member) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Member) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Member) Id() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Member) Addr() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Member) Status() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func MemberStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func MemberAddId(builder *flatbuffers.Builder, id flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(id), 0)
}
func MemberAddAddr(builder *flatbuffers.Builder, addr flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(addr), 0)
}
func MemberAddStatus(builder *flatbuffers.Builder, status flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(status), 0)
}
func MemberEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type MemberList struct {
	_tab flatbuffers.Table
}

func GetRootAsMemberList(buf []byte, offset flatbuffers.UOffsetT) *MemberList {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &MemberList{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *MemberList) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *MemberList) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *MemberList) Members(obj *Member, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *MemberList) MembersLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func MemberListStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func MemberListAddMembers(builder *flatbuffers.Builder, members flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(members), 0)
}
func MemberListStartMembersVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func MemberListEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ClusterStatus struct {
	_tab flatbuffers.Table
}

func GetRootAsClusterStatus(buf []byte, offset flatbuffers.UOffsetT) *ClusterStatus {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ClusterStatus{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *ClusterStatus) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ClusterStatus) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ClusterStatus) Data(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *ClusterStatus) DataLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ClusterStatus) DataBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func ClusterStatusStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func ClusterStatusAddData(builder *flatbuffers.Builder, data flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(data), 0)
}
func ClusterStatusStartDataVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func ClusterStatusEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
